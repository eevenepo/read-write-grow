import json
from pathlib import Path
from typing import Dict, Any, List, Tuple
import sys


class Oligo:
    def __init__(self, huffman_dict_path: Path) -> None:
        with open(huffman_dict_path) as fh:
            # JSON mapping "0".."255" -> ternary code string
            self.huff_dict: Dict[str, str] = json.load(fh)

        # Reverse mapping ternary code -> int byte
        self.rev_huff: Dict[str, int] = {code: int(sym) for sym, code in self.huff_dict.items()}

        # Goldman transition table: prev_base + trit -> next_base
        self.goldman_table = {
            "A": ["C", "G", "T"],
            "C": ["G", "T", "A"],
            "G": ["T", "A", "C"],
            "T": ["A", "C", "G"],
        }
        # Inverse: prev_base + base -> trit
        self.goldman_reverse = {
            "A": {"C": "0", "G": "1", "T": "2"},
            "C": {"G": "0", "T": "1", "A": "2"},
            "G": {"T": "0", "A": "1", "C": "2"},
            "T": {"A": "0", "C": "1", "G": "2"},
        }

    # ---------- BYTES ↔ TERNARY (Huffman) ----------

    def bytes_to_ternary(self, data: bytes) -> str:
        """Encode an arbitrary byte stream to a single ternary string."""
        out: List[str] = []
        for b in data:
            code = self.huff_dict[str(b)]  # dict keys are "0".."255"
            out.append(code)
        return "".join(out)

    def ternary_to_bytes(self, ternary: str) -> bytes:
        """
        Decode a ternary Huffman stream back to bytes.

        Assumes a fixed-length code for each byte (0..255),
        as generated by huffman_bytes_dict.json.
        """
        if not self.rev_huff:
            self.rev_huff = {code: int(sym) for sym, code in self.huff_dict.items()}

        code_len = len(next(iter(self.huff_dict.values())))
        if any(len(c) != code_len for c in self.huff_dict.values()):
            raise ValueError("ternary_to_bytes assumes fixed-length codes")

        decoded: List[int] = []
        n = len(ternary)
        full_len = (n // code_len) * code_len

        if n % code_len != 0:
            print(
                f"WARNING: ternary length {n} is not a multiple of code length {code_len}. "
                f"Ignoring last {n - full_len} trits.",
                file=sys.stderr,
            )

        for i in range(0, full_len, code_len):
            chunk = ternary[i : i + code_len]
            if chunk not in self.rev_huff:
                raise ValueError(f"Unknown Huffman code chunk: {chunk}")
            decoded.append(self.rev_huff[chunk])

        return bytes(decoded)

    # ---------- TERNARY ↔ DNA (Goldman) ----------

    def ternary_to_goldman(self, digits: str, start: str = "A") -> str:
        dna: List[str] = []
        prev = start
        for d in digits:
            base = self.goldman_table[prev][int(d)]
            dna.append(base)
            prev = base
        return "".join(dna)

    def goldman_to_ternary(self, dna: str, start: str = "A") -> str:
        tern: List[str] = []
        prev = start
        for base in dna:
            tern.append(self.goldman_reverse[prev][base])
            prev = base
        return "".join(tern)


# ---------- Shared helpers (indexing, RC, orientation, assembly) ----------


def reverse_complement(seq: str) -> str:
    comp = {"A": "T", "T": "A", "C": "G", "G": "C"}
    return "".join(comp[b] for b in reversed(seq))


def int_to_fixed_trits(n: int, length: int) -> str:
    """
    Convert integer n to base-3 string with fixed length, padded with leading zeros.
    Raises if n doesn't fit in 'length' trits.
    """
    if n < 0:
        raise ValueError("n must be non-negative")

    digits: List[str] = []
    x = n
    while x > 0:
        digits.append(str(x % 3))
        x //= 3

    while len(digits) < length:
        digits.append("0")

    if len(digits) > length:
        raise ValueError(f"value {n} does not fit in {length} trits")

    return "".join(reversed(digits))


def encode_index_trits(file_id: int, fragment_index: int) -> str:
    """
    15-trit index:
        [file_id: 2 trits][fragment_index: 12 trits][parity: 1 trit]
    parity = (sum of first 14 trits) mod 3
    """
    file_trits = int_to_fixed_trits(file_id, 2)
    frag_trits = int_to_fixed_trits(fragment_index, 12)
    head = file_trits + frag_trits
    total = sum(int(ch) for ch in head)
    parity_trit = str(total % 3)
    return head + parity_trit


def trits_to_int(trits: str) -> int:
    n = 0
    for ch in trits:
        n = n * 3 + int(ch)
    return n


def decode_index_trits(index_trits: str) -> Tuple[int, int, bool]:
    """
    Inverse of encode_index_trits.
    Returns:
        file_id, fragment_index, parity_ok
    """
    if len(index_trits) != 15:
        raise ValueError(f"Index trits must be length 15, got {len(index_trits)}")

    head = index_trits[:14]
    parity_trit = index_trits[14]

    file_id_trits = head[:2]
    frag_trits = head[2:]

    file_id = trits_to_int(file_id_trits)
    fragment_index = trits_to_int(frag_trits)

    total = sum(int(ch) for ch in head)
    expected_parity = total % 3
    parity_ok = expected_parity == int(parity_trit)

    return file_id, fragment_index, parity_ok


def trits_to_dna_with_prev(prev_base: str, trits: str, oligo_codec: Oligo) -> str:
    """
    Use the same Goldman mapping as Oligo to map trits -> DNA continuing from prev_base.
    """
    dna: List[str] = []
    prev = prev_base
    for d in trits:
        base = oligo_codec.goldman_table[prev][int(d)]
        dna.append(base)
        prev = base
    return "".join(dna)


def orient_oligo(seq: str) -> str:
    """
    Ensure oligo is in forward orientation:
      encoder: start in {A,T}, end in {C,G}
      if we see the opposite, reverse-complement.
    """
    if len(seq) < 10:
        raise ValueError("Oligo too short to be valid")

    start, end = seq[0], seq[-1]

    if start in "AT" and end in "CG":
        return seq
    if start in "CG" and end in "AT":
        return reverse_complement(seq)

    print(
        f"WARNING: ambiguous orientation for oligo starting {start} ending {end}",
        file=sys.stderr,
    )
    return seq


def fragment_master_dna(
    dna: str,
    file_id: int,
    payload_len: int = 100,
    overlap: int = 20,
) -> List[Dict[str, Any]]:
    """
    Fragment a master DNA string into overlapping payloads with index and orientation:

      - payload length = payload_len (default 100 nt)
      - overlap between successive payloads = overlap (default 20 nt)
      - step = payload_len - overlap
      - odd fragments are reverse-complemented
      - each fragment gets a 15-nt index block (Goldman from the last payload base)
      - 1-nt orientation bases at start (A/T) and end (C/G)

    Returns a list of fragment dicts, each with a full 'sequence' field (117 nt).
    """
    dummy = Oligo(huffman_dict_path=Path("oligos/huffman_bytes_dict.json"))

    step = payload_len - overlap
    fragments: List[Dict[str, Any]] = []
    i = 0

    for start in range(0, max(1, len(dna) - payload_len + 1), step):
        payload = dna[start : start + payload_len]
        if len(payload) < payload_len:
            break

        # Reverse-complement odd fragments
        if i % 2 == 1:
            payload = reverse_complement(payload)

        index_trits = encode_index_trits(file_id, i)
        index_dna = trits_to_dna_with_prev(payload[-1], index_trits, dummy)

        first_payload_base = payload[0]
        orientation_start = "A" if first_payload_base != "A" else "T"

        last_index_base = index_dna[-1]
        orientation_end = "C" if last_index_base != "C" else "G"

        full_seq = orientation_start + payload + index_dna + orientation_end

        fragments.append(
            {
                "file_id": file_id,
                "fragment_index": i,
                "payload": payload,
                "index_trits": index_trits,
                "index_dna": index_dna,
                "orientation_start": orientation_start,
                "orientation_end": orientation_end,
                "sequence": full_seq,
            }
        )
        i += 1

    return fragments


def assemble_master_dna(
    fragments: List[Dict[str, Any]],
    overlap: int = 20,
    payload_len: int = 100,
) -> str:
    """
    Given fragments (as produced by fragment_master_dna), reassemble the master DNA string.
      - sort by fragment_index
      - undo reverse complement on odd fragments
      - stitch by overlap
    """
    if not fragments:
        return ""

    frags = sorted(fragments, key=lambda f: f["fragment_index"])

    # undo RC for odd ones
    for frag in frags:
        if frag["fragment_index"] % 2 == 1:
            frag["payload"] = reverse_complement(frag["payload"])

    master = frags[0]["payload"]
    for frag in frags[1:]:
        payload = frag["payload"]
        if master[-overlap:] != payload[:overlap]:
            print(
                f"WARNING: overlap mismatch at fragment {frag['fragment_index']}",
                file=sys.stderr,
            )
        master += payload[overlap:]

    return master
